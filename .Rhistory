knitr::opts_chunk$set(echo = FALSE)
library(caret)
library(tidyverse)
library(mice)
library("RColorBrewer")
library(VIM)
library("GGally")
install.packages("GGally")
library(caret)
library(tidyverse)
library(mice)
library("RColorBrewer")
library(VIM)
library("GGally")
library("ggmap")
require(maps)
library(MASS)
library(ROCR)
library(rpart)
library(rpart.plot)
learn = read.csv("projet-app-13-learn.csv",header = TRUE,encoding = "UTF-8")
test = read.csv("projet-app-13-test.csv",header = TRUE,encoding = "UTF-8")
glimpse(learn)
learn <- learn %>% rename(categorie = catégorie)
test <- test %>% rename(categorie = catégorie)
learn$reg = as.factor(learn$reg)
learn$categorie = as.factor(learn$categorie)
test$reg = as.factor(test$reg)
test$categorie = as.factor(test$categorie)
cities_gps = read.csv("cities-gps.csv",header = TRUE,encoding = "UTF-8")
cities_population = read.csv("cities-population.csv",header = TRUE,encoding = "UTF-8")
dept = read.csv("departments.csv",header = TRUE,encoding = "UTF-8")
regions = read.csv("regions.csv",header = TRUE,encoding = "UTF-8")
learn=merge(x=learn,y=cities_gps,by.x = "insee.code",by.y="id")
learn=merge(x=learn,y=cities_population,by.x = "insee.code",by.y="id")
learn=merge(x=learn,y=regions,by.x = "reg",by.y="id")
test=merge(x=test,y=cities_gps,by.x = "insee.code",by.y="id")
test=merge(x=test,y=cities_population,by.x = "insee.code",by.y="id")
test=merge(x=test,y=regions,by.x = "reg",by.y="id")
learn <- learn %>% rename(REGION = name)
test <- test %>% rename(REGION = name)
learn$cible <- as.character(learn$cible)
learn$cible[learn$cible == "failure"]<-FALSE
learn$cible[learn$cible == "success"]<-TRUE
learn$cible <- as.logical(learn$cible)
colSums(is.na(learn))
colSums(is.na(test))
respattern=md.pattern(learn,rotate.names = TRUE)
matrixplot(learn)
ggplot(learn, aes(revenue))+geom_histogram(fill="firebrick",bins=40)
marginplot(learn[,c("revenue","age")])
marginplot(learn[,c("revenue","categorie")])
marginplot(learn[,c("revenue","sex")])
marginplot(learn[,c("revenue","cible")])
nrow(subset(learn, is.na(revenue) & cible =="failure"))
nrow(subset(learn, is.na(revenue) & cible =="success"))
ggplot(learn, aes(cible))+geom_bar(fill="firebrick")
par(mfrow=c(2,2))
ggplot(learn, aes(cible,age))+geom_boxplot(fill="deepskyblue")
ggplot(learn, aes(cible,population))+geom_boxplot(fill="darkorange")
ggplot(learn, aes(cible,revenue))+geom_boxplot(fill="darkorchid")
ggplot(learn, aes(x = cible, y = age, fill = sex)) + geom_boxplot()+scale_fill_brewer(palette="Set2")
table(learn$sex, learn$cible)
ggplot(learn, aes(REGION)) + geom_bar(aes(fill=cible),position = "dodge") + scale_fill_brewer(palette="Set1")+theme(axis.text.x = element_text(angle = 90))
table(learn$REGION, learn$cible)
ggplot(learn, aes(REGION)) + geom_bar(aes(fill=cible),position = "dodge") + scale_fill_brewer(palette="Set1")+theme(axis.text.x = element_text(angle = 90))
table(learn$REGION, learn$cible)
ggplot(learn, aes(categorie))+geom_bar(aes(fill=cible))+scale_fill_brewer(palette="PiYG")
table(learn$categorie, learn$cible)
ggplot(learn, aes(city.type))+geom_bar(aes(fill=cible),position = "dodge") + scale_fill_brewer(palette="Accent")+theme(axis.text.x = element_text(angle = 90))
table(learn$city.type, learn$cible)
ggplot(learn, aes(x = city.type, y = age)) + geom_boxplot(aes(fill=cible))+theme(axis.text.x = element_text(angle = 90))
learn2 <-subset(learn,select=-c(insee.code,f_name,last.name,commune, department, latitude,longitude, X, Y, REGION, city.type, reg))
ggpairs(learn2,aes(color="blue"))
set.seed(123) ## pour pouvoir le reproduire
learn3 = subset(learn, select=-c(insee.code,f_name,last.name,commune, department, latitude, longitude,X,Y,reg,revenue))
trainIndex = createDataPartition(learn3$cible,p=0.7, list=FALSE,times=1)
train = learn3[trainIndex,]
valid = learn3[-trainIndex,]
model1<-glm(cible~., data=train,family = binomial(logit))
model2<-glm(cible ~ 1, data=train,family = binomial(logit))
model2.step <- stepAIC(model2, direction = "both", scope=list(upper=model1,lower=model2),trace = FALSE)
summary(model2.step)
glm.pred1 <- predict(model2.step, newdata = valid, type = "response")
table(glm.pred1 > 0.5, valid$cible)
mean(abs((glm.pred1 > 0.5) - valid$cible), na.rm = T)
opt = optCut$optimalCutoff
library(InformationValue)
install.packages("InformationValue")
library(InformationValue)
optCut <- optimalCutoff(valid$cible, glm.pred1, optimiseFor = "misclasserror",returnDiagnostics = TRUE)
optCut$optimalCutoff
opt = optCut$optimalCutoff
table(glm.pred1 > opt, valid$cible)
fitted.results <- ifelse(glm.pred1 > opt,1,0)
misClasificError <- mean(fitted.results != valid$cible)
misClasificError
print(paste('Accuracy',1-misClasificError))
plot(predict(model2.step),residuals(model2.step))
abline(h=0,lty=2,col="red")
pr <- prediction(glm.pred1, valid$cible)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc
set.seed(123) ## pour pouvoir le reproduire
learn_arbres = subset(learn, select=-c(insee.code,f_name,last.name,commune, department, latitude, longitude,X,Y,reg))
trainIndex = createDataPartition(learn_arbres$cible,p=0.7, list=FALSE,times=1)
train_arbre = learn_arbres[trainIndex,]
valid_arbre = learn_arbres[-trainIndex,]
New.tree <- rpart(cible~.,data=train_arbre,method="class")
plotcp(New.tree)
printcp(New.tree)
tree.pred <- predict(New.tree,newdata = valid_arbre ,type="class")
table(tree.pred, valid_arbre$cible)
pred = prediction(as.numeric(tree.pred), as.numeric(valid_arbre$cible))
roc = performance(pred, measure="tpr", x.measure="fpr")
plot(roc, col="orange", lwd=2)
lines(x=c(0, 1), y=c(0, 1), col="red", lwd=2)
auc <- performance(pred, measure = "auc")
auc <- auc@y.values[[1]]
auc
cp_opt <- 0.00039849
New.tree2 <- rpart(cible~.,data=train_arbre,method="class",control = rpart.control(minsplit = 5, minbucket=5,cp = cp_opt))
New.tree <- rpart(cible~.,data=train_arbre,method="class",control = rpart.control(minsplit = 2, cp = 0.0001))
rpart.plot(New.tree2, type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
cp_opt <- 0.00039849
New.tree2 <- rpart(cible~.,data=train_arbre,method="class",control = rpart.control(minsplit = 5, minbucket=5,cp = cp_opt))
New.tree <- rpart(cible~.,data=train_arbre,method="class",control = rpart.control(minsplit = 2, cp = 0.0001))
rpart.plot(New.tree2, type = 3, clip.right.labs = FALSE, branch = .3, under = TRUE)
unlink('Projet ML_cache', recursive = TRUE)
unlink('Projet ML_cache', recursive = TRUE)
read.csv("projet-app-13-learn.csv",header = TRUE,encoding = "UTF-8")
learn = read.csv("projet-app-13-learn.csv",header = TRUE,encoding = "UTF-8")
test = read.csv("projet-app-13-test.csv",header = TRUE,encoding = "UTF-8")
View(learn)
