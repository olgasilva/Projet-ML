curve(dgamma(x,a4+n3*m3,b4+n3),add=T,col="green")
# n= 1000 individus
curve(dgamma(x,a1+n3*m3,b1+n3),xlim=c(0.4,0.6),ylim=c(0,20),main="n=1000 X ~ poisson(0.5)")
curve(dgamma(x,a2+n3*m3,b2+n3),add=T,col="red")
curve(dgamma(x,a3+n3*m3,b3+n3),add=T,col="blue")
curve(dgamma(x,a4+n3*m3,b4+n3),add=T,col="green")
curve(dgamma(x,a1+n1*m1,b1+n1),xlim=c(0,1),ylim=c(0,5),main="n=20 X ~ poisson(0.5)")
curve(dgamma(x,a2+n1*m1,b2+n1),add=T,col="red")
curve(dgamma(x,a3+n1*m1,b3+n1),add=T,col="blue")
curve(dgamma(x,a4+n1*m1,b4+n1),add=T,col="green")
curve(dgamma(x,a1+n2*m2,b1+n2),xlim=c(0,1),ylim=c(0,6),main="n=100 X ~ poisson(0.5)")
curve(dgamma(x,a2+n2*m2,b2+n2),add=T,col="red")
curve(dgamma(x,a3+n2*m2,b3+n2),add=T,col="blue")
curve(dgamma(x,a4+n2*m2,b4+n2),add=T,col="green")
curve(dgamma(x,a1+n3*m3,b1+n3),xlim=c(0.4,0.6),ylim=c(0,20),main="n=1000 X ~ poisson(0.5)")
curve(dgamma(x,a2+n3*m3,b2+n3),add=T,col="red")
curve(dgamma(x,a3+n3*m3,b3+n3),add=T,col="blue")
curve(dgamma(x,a4+n3*m3,b4+n3),add=T,col="green")
# n= 1000 individus
curve(dgamma(x,a1+n3*m3,b1+n3),xlim=c(0.4,0.6),ylim=c(0,20),main="oi a prosteriori lambda - n=1000 X ~ poisson(0.5)")
c(1, 1, 1, 2) / c(0.5, 2, 10, 2)
(c(1, 1, 1, 2) + sum(y1)) / (c(0.5, 2, 10, 2) +  20)
c=(a1,a2,a3,a4)/c=(b1,b2,b3,b4)
c(a1,a2,a3,a4)/c(b1,b2,b3,b4)
c(a1-1,a2-1,a3-1,a4-1)/c(b1,b2,b3,b4)
(c(a1,a2,a3,a4)+n1*m1)/(c(b1,b2,b3,b4)+n1)
y1 = rpois(20, lambda)
y2 = rpois(100, lambda)
y3 = rpois(1000, lambda)
(c(1, 1, 1, 2) + sum(y1)) / (c(0.5, 2, 10, 2) +  20)
(c(1, 1, 1, 2) + sum(y1)) / (c(0.5, 2, 10, 2) +  20)
y1 = rpois(20, lambda)
y2 = rpois(100, lambda)
y3 = rpois(1000, lambda)
c(1, 1, 1, 2) + sum(y1)) / (c(0.5, 2, 10, 2) +  20)
# espérance a posteriori :
(c(1, 1, 1, 2) + sum(y1)) / (c(0.5, 2, 10, 2) +  20)
# MAP
(c(1, 1, 1, 2) + sum(y1) - 1) / (c(0.5, 2, 10, 2) +  20)
(c(a1,a2,a3,a4)+n1*m1)/(c(b1,b2,b3,b4)+n1)
lambda=0.5
n1=20
echp1=rpois(n1,lambda)
m1=mean(echp1)
n2=100
echp2=rpois(n2,lambda)
m2=mean(echp2)
n3=1000
echp3=rpois(n3,lambda)
m3=mean(echp3)
(c(a1,a2,a3,a4)+n1*m1)/(c(b1,b2,b3,b4)+n1)
(c(a1,a2,a3,a4)+n1*m1)/(c(b1,b2,b3,b4)+n1)
(c(a1,a2,a3,a4)+n2*m2)/(c(b1,b2,b3,b4)+n2)
(c(a1,a2,a3,a4)+n3*m3)/(c(b1,b2,b3,b4)+n3)
(c(a1,a2,a3,a4)+n1*m1-1)/c(b1,b2,b3,b4)
(c(a1,a2,a3,a4)+n2*m2-1)/c(b1,b2,b3,b4)
(c(a1,a2,a3,a4)+n3*m3-1)/c(b1,b2,b3,b4)
(c(1, 1, 1, 2) + sum(y1) - 1) / (c(0.5, 2, 10, 2) +  20)
(c(1, 1, 1, 2) + sum(y2) - 1) / (c(0.5, 2, 10, 2) +  100)
(c(1, 1, 1, 2) + sum(y3) - 1) / (c(0.5, 2, 10, 2) +  1000)
(c(a1,a2,a3,a4)+n1*m1-1)/(c(b1,b2,b3,b4)+n1)
(c(a1,a2,a3,a4)+n2*m2-1)/(c(b1,b2,b3,b4)+n2)
(c(a1,a2,a3,a4)+n3*m3-1)/(c(b1,b2,b3,b4)+n3)
#question 6 : intervalle de crédibilité
?qgamma
qgamma(c(.025, .975), 1 + sum(y1), .5 + 20)
library(mvtnorm)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
sigma
d=read.csv("shuttle.txt",sep="\t")
View(d)
library("mcmc")
#EMV pour beta0 beta1 par le modele probit
modlog=glm(damage~tempF,data=d,family = binomial(link="probit"))
summodlog=summary(modlog)
sigma=summodlog$cov.unscaled
betaEMV=(summodlog$coefficients[,1])
# On peut par exemple prendre des priors N(0,10^2) indépendantes
prior = function(beta){
return(dnorm(beta[1], 0, 10) * dnorm(beta[2], 0, 10))
}
posterior = function(beta, y, x){
p = pnorm(beta[1] + x*beta[2])
lkd = prod(p^y) * prod((1-p)^(1-y))
return(lkd * prior(beta))
}
library(mvtnorm)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
class(tau)
posterior = function(beta, y, x){
p = pnorm(beta[1] + x*beta[2])
lkd = prod(p^y) * prod((1-p)^(1-y))
return(lkd * prior(beta))
}
library(mvtnorm)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
?rmvnorm
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2*det(sigma)) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
# proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
# proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
d=read.csv("shuttle.txt",sep="\t")
View(d)
library("mcmc")
#EMV pour beta0 beta1 par le modele probit
modlog=glm(damage~tempF,data=d,family = binomial(link="probit"))
summodlog=summary(modlog)
sigma=summodlog$cov.unscaled
betaEMV=(summodlog$coefficients[,1])
# On peut par exemple prendre des priors N(0,10^2) indépendantes
prior = function(beta){
return(dnorm(beta[1], 0, 10) * dnorm(beta[2], 0, 10))
}
# loi a posteriori
posterior = function(beta, y, x){
p = pnorm(beta[1] + x*beta[2])
lkd = prod(p^y) * prod((1-p)^(1-y))
return(lkd * prior(beta))
}
library(mvtnorm)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
# proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],tempF,damage)/posterior(beta[i, ],tempF,damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
d=read.csv("shuttle.txt",sep="\t")
View(d)
library("mcmc")
#EMV pour beta0 beta1 par le modele probit
modlog=glm(damage~tempF,data=d,family = binomial(link="probit"))
summodlog=summary(modlog)
sigma=summodlog$cov.unscaled
betaEMV=(summodlog$coefficients[,1])
# On peut par exemple prendre des priors N(0,10^2) indépendantes
prior = function(beta){
return(dnorm(beta[1], 0, 10) * dnorm(beta[2], 0, 10))
}
# loi a posteriori
posterior = function(beta, y, x){
p = pnorm(beta[1] + x*beta[2])
lkd = prod(p^y) * prod((1-p)^(1-y))
return(lkd * prior(beta))
}
library(mvtnorm)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
# proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],d$tempF,d$damage)/posterior(beta[i, ],d$tempF,d$damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
# Bayesien TD 3 Metropolis Hastings sur shuttle.txt
d=read.csv("shuttle.txt",sep="\t")
View(d)
attach(d)
library("mcmc")
#EMV pour beta0 beta1 par le modele probit
modlog=glm(damage~tempF,data=d,family = binomial(link="probit"))
summodlog=summary(modlog)
sigma=summodlog$cov.unscaled
betaEMV=(summodlog$coefficients[,1])
# On peut par exemple prendre des priors N(0,10^2) indépendantes
prior = function(beta){
return(dnorm(beta[1], 0, 10) * dnorm(beta[2], 0, 10))
}
# loi a posteriori
posterior = function(beta, y, x){
p = pnorm(beta[1] + x*beta[2])
lkd = prod(p^y) * prod((1-p)^(1-y))
return(lkd * prior(beta))
}
library(mvtnorm)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
# proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],d$tempF,d$damage)/posterior(beta[i, ],d$tempF,d$damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = min(1,posterior(beta[i-1, ],d$tempF,d$damage)/posterior(beta[i, ],d$tempF,d$damage))# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
MH = function(beta0, niter, tau){
beta = matrix(NA, nrow=niter, ncol=2)
beta[1, ] = beta0
for(i in 2:niter){
proposal = rmvnorm(1, beta[i-1, ], tau^2*sigma) # genere un vecteur de variables aléatoires normale multivariées
alpha = 0.02# probabilité d'acceptation
if(runif(1) < alpha){
# on accepte
}
else{
# on rejette
}
}
return(beta)
}
niter = 2e3
b1 = MH(c(-3,0), niter, 1)
b2 = MH(c(2,0), niter, 1)
b3 = MH(c(2,-0.3), niter, 1)
b4 = MH(c(0, 0), niter, .1)
b5 = MH(c(0, -.01), niter, 1)
install.packages("randomForest")
install.packages("xgboost")
library(matrix)
install.packages("Matrix")
install.packages("zoo")
install.packages("latexpdf")
install.packages("latex2exp")
install.packages("mvtnorm")
?mvtnorm
install.packages("class")
install.packages("ROCR")
library(ROCR)
fr <- data.frame(score = c(0.61, 0.36, 0.43, 0.14, 0.38, 0.24, 0.97, 0.89, 0.78, 0.86, 0.71, 0.36),
label = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0))
pred <- prediction(fr$score, fr$label)
pred
table(pred,fr$score)
library(ROCR)
fr <- data.frame(score = c(0.61, 0.36, 0.43, 0.14, 0.38, 0.24, 0.97, 0.89, 0.78, 0.86, 0.71, 0.36),
label = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0))
pred <- prediction(fr$score, fr$label)
perf <- performance(pred, "tpr", "fpr")
plot(perf)
library(ROCR)
fr <- data.frame(score = c(0.61, 0.36, 0.43, 0.14, 0.38, 0.24, 0.97, 0.89, 0.78, 0.86, 0.71, 0.36),
label = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0))
pred <- prediction(fr$score, fr$label)
perf <- performance(pred, "auc")
perf@y.values[[1]]
library(ROCR)
fr <- data.frame(score = c(0.61, 0.36, 0.43, 0.14, 0.38, 0.24, 0.97, 0.89, 0.78, 0.86, 0.71, 0.36),
label = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0))
pred <- prediction(fr$score, fr$label)
perf <- performance(-pred, "tpr", "fpr")
plot(perf)
library(ROCR)
fr <- data.frame(score = c(0.61, 0.36, 0.43, 0.14, 0.38, 0.24, 0.97, 0.89, 0.78, 0.86, 0.71, 0.36),
label = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0))
pred <- prediction(fr$score, fr$label)
perf <- performance(1/pred, "tpr", "fpr")
plot(perf)
# Courbe de ROC
library(ROCR)
fr <- data.frame(score = c(0.61, 0.36, 0.43, 0.14, 0.38, 0.24, 0.97, 0.89, 0.78, 0.86, 0.71, 0.36),
label = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0))
pred <- prediction(fr$score, fr$label)
perf <- performance(pred, "tpr", "fpr")
plot(perf)
knitr::opts_chunk$set(echo = FALSE)
# Librairies
library(caret)
library(tidyverse)
library(gridExtra)
library(mice)
library("RColorBrewer")
library(VIM)
library("GGally")
library("ggmap")
require(maps)
library(MASS)
library(ROCR)
library(rpart)
library(rpart.plot)
library(InformationValue)
# Librairies
library(caret)
library(tidyverse)
library(gridExtra)
library(mice)
library("RColorBrewer")
library(VIM)
library("GGally")
library("ggmap")
require(maps)
library(MASS)
library(ROCR)
library(rpart)
library(rpart.plot)
library(InformationValue)
install.packages("sf")
install.packages("raster")
install.packages("spData")
install.packages("SpDATALarger")
install.packages("tmap")
install.packages("cowplot")
setwd("C:/Users/Marlène/Desktop/MachineLearning/Projet-ML")
